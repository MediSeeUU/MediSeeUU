import scraping.utilities.definitions.values as values
import scraping.utilities.definitions.sources as src
import scraping.utilities.definitions.attributes as attr
from difflib import SequenceMatcher as SM

# TODO: remove try catch
def get_attribute_date(source_dict: str, file_dicts: dict[str, dict[str, any]]) -> str:
    if source_dict == src.web:
        try:
            return file_dicts[src.web][attr.scrape_date_web]
        except Exception:
            return values.default_date
    else:
        try:
            file_name = file_dicts[source_dict][attr.pdf_file]
            return file_dicts[src.web][file_name][attr.meta_file_date]
        except:
            return values.default_date


def check_all_equal(values: list[any]) -> bool:
    """
    checks if two values are equal and not None
    Args:
        v1 (any): value to compare
        v2 (any): value to compare

    Returns (bool): result of check
    """
    if len(values) == 0:
        return False

    all_same = True
    for value in values[1:]:
        all_same &= value == values[0]

    return all_same and values[0] is not None


def combine_best_source(attribute_name: str, sources: list[str], file_dicts: dict[str, dict[str, any]]) -> any:
    """

    Args:
        attribute_name:
        dicts:
        combine_attributes:

    Returns:

    """
    attributes: list[str] = []

    for source in sources:
        dict = file_dicts[source]
        try:
            attributes.append(dict[attribute_name])
        except Exception:
            print("COMBINER: can't find value for ", attribute_name, " in ", source)
            # print("COMBINER: can't find value for ", attribute_name, " in ", dict[attr.source_file])

    attributes.append(values.not_found)
    return attributes[0]


# For combine functions
# TODO: fix datum
def combine_select_string_overlap(attribute_name: str, sources: list[str], file_dicts: dict[str, dict[str, any]],
                                  min_matching_fraction: float = 0.8) -> bool:
    """
    compares two strings to see if a percentage of the shortest string is identical to the longest string
    Args:
        s1 (str): first string
        s2 (str): second string
        perc (float): percentage float between 0 and 1

    Returns (bool): bool indicating equality
    """
    strings = []
    for source in sources:
        dict = file_dicts[source]
        try:
            strings.append(dict[attribute_name])
        except Exception:
            print("COMBINER: can't find value for ", attribute_name, " in ", source)
            # print("COMBINER: can't find value for ", attribute_name, " in ", dict[attr.source_file])
    try:
        old_string = strings[0]
        new_string = strings[1]
        sequence_matcher = SM(None, old_string.lower(), new_string.lower())
        overlap = sequence_matcher.find_longest_match(0, len(old_string) - 1, 0, len(new_string) - 1)

        for string in strings[1:]:
            old_string = new_string
            new_string = string
            sequence_matcher = SM(None, old_string.lower(), new_string.lower())
            overlap = sequence_matcher.find_longest_match(0, len(old_string), 0, len(new_string))


        if float(overlap.size / len(strings[0])) >= min_matching_fraction:
            return (strings[0][overlap.a:overlap.a + overlap.size], values.default_date)
    except Exception:
        print("no second string")

    return (values.insufficient_overlap, get_attribute_date(sources[0], file_dicts))


def combine_eu_med_type(attribute_name: str, sources: list[str], file_dicts: dict[str, dict[str, any]]) -> str:
    """_summary_

    Args:
        filedicts (dict[str, dict[str, any]]): Dictionary of all source dictionaries generated by combine_folder()

    Returns:
        str: _description_
    """
    annex_initial_dict = file_dicts[src.annex_initial]
    eu_med_type = annex_initial_dict[attr.eu_med_type]
    eu_med_type_date = get_attribute_date(annex_initial_dict, file_dicts)
    eu_atmp = file_dicts[src.decision][attr.eu_atmp]

    if eu_med_type == values.eu_med_type_biologicals and eu_atmp:
        return (values.eu_med_type_atmp, eu_med_type_date)

    return (eu_med_type, eu_med_type_date)


def json_static(value: any, date: str) -> any:
    print("json_static")
    print(value)
    return value


def json_history_current(value: any, date: str) -> dict[str, any]:
    print("history")
    json_dict = {}
    json_dict["value"] = value
    json_dict["date"] = date
    return [json_dict]


def json_history_initial(value: any, date: str) -> list[dict[str, any]]:
    print("history_initial")
    json_dict = {}
    json_dict["value"] = value
    json_dict["date"] = date
    return json_dict
