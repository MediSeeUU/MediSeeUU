import definitions.value as values
import definitions.attributes as attr
from difflib import SequenceMatcher as SM

def check_all_equal(values: list[any]) -> bool:
    """
    checks if two values are equal and not None
    Args:
        v1 (any): value to compare
        v2 (any): value to compare

    Returns (bool): result of check
    """
    if len(values) == 0:
        return False

    all_same = True
    for value in values[1:]:
        all_same &= value == values[0]

    return all_same and values[0] is not None


def combine_best_source(attribute_name: str, sources: list[str], file_dicts: dict[str, dict[str, any]]) -> (any, str):
    """

    Args:
        attribute_name:
        dicts:
        combine_attributes:

    Returns:

    """
    attributes: list[str] = []

    for source in sources:
        dict = file_dicts[source]
        source_date = get_file_date(source, file_dicts)
        try:
            attributes.append((dict[attribute_name], source_date))
        except Exception:
            print("COMBINER: can't find value for ", attribute_name, " in ", source)
            # print("COMBINER: can't find value for ", attribute_name, " in ", dict[attr.source_file])

    attributes.append(values.not_found, values.invalid_date)
    return attributes[0]


# For combine functions
#TODO: fix datum
def combine_select_string_overlap(attribute_name: str, sources: list[str], file_dicts: dict[str, dict[str, any]], min_matching_fraction: float = 0.8) -> bool:
    """
    compares two strings to see if a percentage of the shortest string is identical to the longest string
    Args:
        s1 (str): first string
        s2 (str): second string
        perc (float): percentage float between 0 and 1

    Returns (bool): bool indicating equality
    """
    strings = []
    for source in sources:
        dict = file_dicts[source]
        try:
            strings.append(dict[attribute_name])
        except Exception:
            print("COMBINER: can't find value for ", attribute_name, " in ", source)
            # print("COMBINER: can't find value for ", attribute_name, " in ", dict[attr.source_file])


    overlap = SM.find_longest_match(strings[0], strings[1])

    for string in strings[1:]:
        overlap = SM.find_longest_match(overlap, string)

    if len(min(strings, key=len)) / len(overlap) >= min_matching_fraction:
        return (overlap, values.invalid_date)

    return (values.insufficient_overlap, values.invalid_date)


def combine_eu_med_type(attribute_name: str, sources: list[str], file_dicts: dict[str, dict[str, any]]) -> str:
    """_summary_

    Args:
        filedicts (dict[str, dict[str, any]]): Dictionary of all source dictionaries generated by combine_folder()

    Returns:
        str: _description_
    """
    annex_initial_dict = file_dicts[attr.annex_initial]
    eu_med_type = annex_initial_dict[attr.eu_med_type]
    eu_med_type_date = get_file_date(annex_initial_dict, file_dicts)
    eu_atmp = file_dicts[attr.decision][attr.eu_atmp]

    if eu_med_type == values.eu_med_type_biologicals and eu_atmp:
        return (values.eu_med_type_atmp, eu_med_type_date)
    
    return (eu_med_type, eu_med_type_date)


def json_static(value: any, date: str) -> any:
    return value


def json_history_current(value: any, date: str) -> dict[str, any]:
    return {"value": value, "date": date}


def json_history_initial(value: any, date: str) -> list[dict[str, any]]:
    return [{"value": value, "date": date}]


def get_file_date(source_dict: dict[str, any], file_dicts: dict[str, dict[str, any]]) -> str:
    file_name = source_dict[attr.pdf_file]
    file_dates = file_dicts[attr.file_dates]
    return file_dates[file_name][attr.file_date]

