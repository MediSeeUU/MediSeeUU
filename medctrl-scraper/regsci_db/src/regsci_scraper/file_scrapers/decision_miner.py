# This program has been developed by students from the bachelor Computer Science at
# Utrecht University within the Software Project course.
# © Copyright Utrecht University (Department of Information and Computing Sciences)
# Contains the following variables to mine in EC Authorisation Decision PDF files
# 1 Brand name
# 2 Legal scope
# 3 Decision Type
# 4 Decision Date
# 6 ODD: Orphan Drug Designation
# 7 ATMP
# 8 New active substance

from regsci_scraper import utils

import re
from loguru import logger


def extract_brandname_1(text: str):
    """ Extracts brand name from text generated by extract_data

    Parameters
    ----------
    text: text generated by extract_data

    Returns
    -------
    research: the results of the Regex retrieval
    brand_name: The name of the brand retrieved from the decision PDF file
    """
    # regex is looking for structure "brand name - active substance"
    research = re.search(r'"(\w+[\s\w®/\.,"]*)\s?[-–]\s?\w+.*"', text)

    brand_name = utils.try_block(research, idx=1)

    if brand_name is None:  # if no brand name found, go to next text item
        brand_name = None
    else:  # else brand name found: stop loop
        logger.info(f"found brand name: '{brand_name}'")

    if brand_name is None:  # if no brand name found in all text items: return None
        logger.info(f"no brand name found in PDF")
        return None
    else:  # else return brand name
        return brand_name.strip()


def extract_legalscope(text: str):
    """ Extracts the legal scope of the decision PDF. Two options possible as defined in the list 'scopes'

    Parameters
    ----------
    text: The raw text of the decision PDF file

    Returns
    -------
    legal_scopes: a list containing one of the two scopes or in some cases both.
    """
    scopes = [
        "Council Regulation (EEC) No 2309/93",
        "Regulation (EC) No 726/2004"
    ]
    legal_scopes = []  # it is possible that multiple scopes are found, hence list

    for scope in scopes:
        if scope in text:
            legal_scopes.append(scope)

    legal_scopes = list(set(legal_scopes))  # remove redundant hits

    if len(legal_scopes) == 0:
        logger.info("legal scope not found")
        return None
    else:
        logger.info(f"found legal scope: '{legal_scopes}'")
        legal_scopes = " AND ".join(legal_scopes)
        return legal_scopes


def extract_decisiontype(text: str):
    """ Extract the type of decision [categorical, exceptional, standard]

    Parameters
    ----------
    text: The raw text of the decision PDF file

    Returns
    -------
    one of the following [categorical, exceptional, standard]
    """
    excep = re.search(r"article\s+14\W8", text.lower())  # exceptional: Article 14(8) or alt. (e.g. Article 14.8)

    # conditional
    if "507/2006" in text or "conditional marketing authorisation" in text.lower():
        return "conditional"

    # exceptional
    elif "exceptional circumstances" in text.lower() or excep is not None:
        return "exceptional"
    else:
        return None


def extract_decisiondate(text: str):
    """ Extract the date of decision in dd/mm/yyyy

    Parameters
    ----------
    text: The raw text of the decision PDF file

    Returns
    -------
    date: The date in dd/mm/yyyy
    """
    research = re.search(r'DECISION\s?[Oo]f ([0-3]?\d\s?[\.\/-]\s?[0-1]?\d\s?[\.\/-]\s?[1-2]\d\d\d)', text)
    date = utils.try_block(research, idx=1)

    # if no date found try roman numbering for months
    if date is None:
        research = re.search(r' DECISION\s?[Oo]f ([0-3]?\d\s?[\.\/-]\s?[XVI]{1,4}\s?[\.\/-]\s?[1-2]\d\d\d)', text)
        date = utils.try_block(research, idx=1)
        if date is not None:
            date = utils.convert_roman_numbers(date)
            logger.info(f"found decision date: '{date}'")

    # if no date found try to search for written months
    if date is None:
        research = re.search(r'DECISION\s?[Oo]f ([0-3]?\d\s\w+\s[1-2]\d\d\d)', text)
        date = utils.try_block(research, idx=1)
        if date is not None:
            date = utils.convert_months(date)
            logger.info(f"found decision date: '{date}'")

    # if no date found try looking for yy digits
    if date is None:
        research = re.search(r'DECISION\s?[Oo]f\s?([0-3]?\d\s?[\.\/-]\s?[0-1]?\d\s?[\.\/-]\s?(\d\d))\s', text)
        date = utils.try_block(research, idx=1)
        if date is not None:
            yy = research[2]
            yyyy = utils.convert_to_yyyy(yy)
            date = date[:-2] + yyyy
            logger.info(f"found decision date: '{date}'")

    if date is None:
        return None
    else:
        # convert to dd/mm/yyyy
        date = date.replace(".", "/", 2).replace("-", "/", 2).replace(" ", "")  # [.-] -> /  rm spaces
        return date


def extract_odd(text: str, odd: str = None):
    """Check if medicine was granted Orphan Designation

    Parameters
    ----------
    text: The raw text of the decision PDF file
    odd: result from previous text search (see RegSciMiner class in pdf_scraper.py)
    Returns
    -------
    odd: Categorical: [adopted, appointed, no]
    """
    w_idx = text.find("Whereas:")  # find the paragraph that starts with "Whereas:"
    whereas = text[w_idx:]
    h_idx = text.lower().find("has adopted this decision:")  # find paragraph that adopts decision
    if h_idx == -1:  # -1 == string not found in text
        adopted = None
    else:
        whereas = whereas[:h_idx]
        adopted = text[h_idx:]

    # Search first for 'adoption', then for 'appointed' and lastly decide 'no'
    # if previous odd value is anything, only adopted can be found
    if adopted is not None and "orphan medicinal product" in adopted.lower():
        odd = "adopted"
    # elif adopted is not found and odd is not already 'appointed' search for appointed:
    elif odd in [None, "no"] and "an orphan medicinal product" in whereas.lower() and "Regulation (EC) No 141/2000" in whereas:
        odd = "appointed"
    # elif both appointed and addopted not found and odd is not already 'no'
    elif odd is None:
        odd = "no"
    # in the case 'odd' is already 'no', odd remains odd
    else:
        odd = odd

    return odd


def extract_atmp(text: str):
    """ Check if product is classified as ATMP under ATMP regulation 1394/2007

    Parameters
    ----------
    text: The raw text of the decision PDF file

    Returns
    -------
    Boolean: "yes" if ATMP regulation found in text, else "no"
    """
    regulation = "Regulation (EC) No 1394/2007"
    fn_idx = text.find("Regulation as last amended by")  # sometimes regulation is mentioned in footnote
    footnote = text[fn_idx:fn_idx+70]  # select the sentence if the regulation is mentioned in the footnote
    text = text.replace(footnote, "")  # remove the footnote with the regulation from the text
    if regulation in text:
        return "yes"
    else:
        return "no"


def extract_new_as(text: str):
    """Check if medicine contains New Active Substance, as recognized by CHMP

    Parameters
    ----------
    text: The raw text of the decision PDF file

    Returns
    -------
    Boolean: "yes" if new active substance, else "no"
    """
    if "committee for medicinal products for human use" in text.lower() and "a new active substance" in text.lower():
        return "yes"
    else:
        return "no"
